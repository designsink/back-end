name: dsink

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    - name: Build with Gradle (skip tests)
      run: ./gradlew build -x test

    - name: Deploy to server
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.EC2_SSH_KEY }}
        envs: DB_URL,DB_USERNAME,DB_PASSWORD,JWT_SECRET_KEY,FILE_UPLOAD
        script: |
          cd ~/app

          # uploads ë””ë ‰í† ë¦¬ ìƒì„±
          mkdir -p uploads

          # 8080 í¬íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  í”„ë¡œì„¸ìŠ¤ í™•ì¸ ë° ì •ë¦¬
          echo "ğŸ” Checking processes using port 8080..."
          sudo netstat -tlnp | grep :8080 || echo "No processes found on port 8080"

          # 8080 í¬íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ì»¨í…Œì´ë„ˆë“¤ ê°•ì œ ì¢…ë£Œ
          echo "ğŸ›‘ Stopping containers using port 8080..."
          docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | grep 8080 | awk '{print $1}' | xargs -r docker stop
          docker ps -a --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}" | grep 8080 | awk '{print $1}' | xargs -r docker rm

          # ê¸°ì¡´ dsink-app ì»¨í…Œì´ë„ˆ ì™„ì „ ì •ë¦¬
          echo "ğŸ§¹ Cleaning up existing dsink-app containers..."
          docker stop dsink-back || true
          docker rm dsink-back || true

          # ì ì‹œ ëŒ€ê¸° (í¬íŠ¸ í•´ì œ ëŒ€ê¸°)
          echo "â³ Waiting for port to be released..."
          sleep 5

          # ê¸°ì¡´ ì´ë¯¸ì§€ ì œê±°
          echo "ğŸ—‘ï¸ Removing old images..."
          docker rmi dsink-back:latest || true

          # ìƒˆ ì´ë¯¸ì§€ ë¹Œë“œ
          echo "ğŸ”¨ Building new image..."
          docker build -t dsink-app:latest .

          # ë¹Œë“œ ì„±ê³µ í™•ì¸
          if [ $? -ne 0 ]; then
              echo "âŒ Docker build failed!"
              exit 1
          fi

          # í¬íŠ¸ ì‚¬ìš© ì¬í™•ì¸
          if netstat -tlnp | grep :8080; then
              echo "âŒ Port 8080 is still in use. Please check manually."
              netstat -tlnp | grep :8080
              exit 1
          fi

          # ì»¨í…Œì´ë„ˆ ì‹¤í–‰
          echo "ğŸš€ Starting new container..."
          docker run -d \
            --name dsink-back \
            --network dsink \
            -p 8080:8080 \
            -v ~/app/uploads:/app/uploads \
            -e DB_URL="$DB_URL" \
            -e DB_USERNAME="$DB_USERNAME" \
            -e DB_PASSWORD="$DB_PASSWORD" \
            -e JWT_SECRET_KEY="$JWT_SECRET_KEY" \
            -e FILE_UPLOAD="$FILE_UPLOAD" \
            --restart unless-stopped \
            dsink-back:latest

          # ì»¨í…Œì´ë„ˆ ì‹œì‘ í™•ì¸
          if [ $? -ne 0 ]; then
              echo "âŒ Failed to start container!"
              docker logs dsink-app --tail=20
              exit 1
          fi

          # ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ ì •ë¦¬
          echo "ğŸ§¹ Cleaning up unused images..."
          docker image prune -f

          echo "ğŸ‰ Deployment completed successfully!"
          echo "ğŸ“Š Container status:"
          docker ps | grep dsink-app
      env:
        DB_URL: ${{ secrets.DB_URL }}
        DB_USERNAME: ${{ secrets.DB_USERNAME }}
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        FILE_UPLOAD: ${{ secrets.FILE_UPLOAD }}
